name: Release .NET Application AppA

on:
  workflow_dispatch

jobs:
  build-and-release:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3
      with:
        fetch-depth: 0 # Important to fetch all history for scripts calculating changes

    - name: Determine Changeset for AppA
      id: changeset
      run: |
        # Attempt to get the last tag, defaulting to the initial commit if none exist
        LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo $(git rev-list --max-parents=0 HEAD))

        # Echo the last tag or initial commit for debugging purposes
        echo "Using base reference: $LAST_TAG"
    
        # List all changed files since the last tag, filtering by those in the AppA or Core directories
        CHANGED_FILES=$(git diff --name-only $LAST_TAG HEAD | grep -E "src/Test/AppA/")
        echo "Changed Files: $CHANGED_FILES"
        
        # Check if the variable is empty or not
        if [[ -z "$CHANGED_FILES" ]]; then
          echo "APPA_AFFECTED=false" >> $GITHUB_ENV
          echo "APPA_AFFECTED=false"
        else
          echo "APPA_AFFECTED=true" >> $GITHUB_ENV
          echo "APPA_AFFECTED=true"
        fi

    - name: Build and Test Application
      if: env.APP_AFFECTED == 'true'
      run: |
        # Insert commands to build and test your .NET application
        dotnet build ./src/Test/AppA/Test.Api.App.A
        dotnet test ./src/Test/AppA/tests/Test.Api.App.A.Tests

    - name: Calculate next version for AppA
      id: calc_version
      if: env.APPA_AFFECTED == 'true'
      run: |
        # Enable case-insensitive matching
        shopt -s nocasematch
    
        # Ensure all tags are fetched
        git fetch --tags
    
        # Get the latest version tag for App1
        LATEST_TAG=$(git tag --list 'appA-*' --sort=-v:refname | head -n 1)
        if [[ -z "$LATEST_TAG" ]]; then
          LATEST_TAG="appA-v0.0.0"
        fi
        echo "Latest tag: $LATEST_TAG"
        echo "LATEST_TAG=$LATEST_TAG" >> $GITHUB_ENV
    
        # Initialize version components from the latest tag
        #PREFIX=$(echo $LATEST_TAG | grep -o '^[^-]*') # Extract prefix (appA-v)
        PREFIX=$(echo $LATEST_TAG | grep -oE '^[^-]+-v')
        echo "Prefix: $PREFIX"
        VERSION=$(echo $LATEST_TAG | sed -e "s/^$PREFIX//") # Remove prefix
        echo "Version less prefix: $(echo $LATEST_TAG | sed -e "s/^$PREFIX//")"
        MAJOR=$(echo $VERSION | cut -d '.' -f 1)
        echo "Major: $(echo $VERSION | cut -d '.' -f 1)"
        MINOR=$(echo $VERSION | cut -d '.' -f 2)
        echo "Minor: $(echo $VERSION | cut -d '.' -f 2)"
        PATCH=$(echo $VERSION | cut -d '.' -f 3)
        echo "Patch: $(echo $VERSION | cut -d '.' -f 3)"
    
        # Initialize increment variables
        MAJOR_INC=0
        MINOR_INC=0
        PATCH_INC=0
    
        # Use git diff to analyze commits for version bump, filtering by appA directory
        COMMIT_IDS=$(git log $LATEST_TAG..HEAD --pretty=format:"%H")
        for COMMIT_ID in $COMMIT_IDS
        do
          # Check if the commit affects the appA directory
          if git diff --name-only $COMMIT_ID^! | grep -q 'src/Test/AppA/'; then
            #COMMIT_MSG=$(git log -1 --pretty=format:"%s" $COMMIT_ID)
            COMMIT_MSG=$(git log -1 --pretty=format:"%s" $COMMIT_ID)
            if [[ "$COMMIT_MSG" =~ BREAKING[[:space:]]CHANGE: ]]; then
              MAJOR_INC=1
              break # Stop processing further commits as major version increment is required
            elif [[ "$COMMIT_MSG" =~ ^feat: ]]; then
              MINOR_INC=1
            elif [[ "$COMMIT_MSG" =~ ^fix: ]]; then
              PATCH_INC=1
            fi
          fi
        done

        # Disable case-insensitive matching after use
        shopt -u nocasematch
    
        # Calculate next version based on increments
        if [[ $MAJOR_INC -eq 1 ]]; then
          MAJOR=$(($MAJOR + 1))
          MINOR=0
          PATCH=0
        elif [[ $MINOR_INC -eq 1 ]]; then
          MINOR=$(($MINOR + 1))
          PATCH=0
        elif [[ $PATCH_INC -eq 1 ]]; then
          PATCH=$(($PATCH + 1))
        fi
    
        NEXT_VERSION="$PREFIX$MAJOR.$MINOR.$PATCH"
        echo "Next version: $NEXT_VERSION"
        echo "next_version=$NEXT_VERSION" >> $GITHUB_OUTPUT
        
        if [[ "$NEXT_VERSION" == "$LATEST_TAG" ]]; then
          echo "VERSION_CHANGED=false" >> $GITHUB_ENV
          echo "VERSION_CHANGED=false"
        else
          echo "VERSION_CHANGED=true" >> $GITHUB_ENV
          echo "VERSION_CHANGED=true"
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Get last tag for the application
      id: last-tag
      run: |
        echo "$(git tag --list 'appA*' --sort=-version:refname | head -n 1)"
        echo "::set-output name=tag::$(git tag --list 'appA*' --sort=-version:refname | head -n 1)"
      env:
        APP_PREFIX: 'appA'

    - name: Get commits since last tag for the application
      id: get-commits
      run: |
        echo "Git log of commits since last tag:"
        git log ${{ steps.last-tag.outputs.tag }}..HEAD --pretty=format:"%h %s" -- 'src/Test/AppA/'
        commits=$(git log ${{ steps.last-tag.outputs.tag }}..HEAD --pretty=format:"%h %s"  -- 'src/Test/AppA/' | base64)
        echo "Outputting commits:"
        echo $commits
        echo "::set-output name=commits::$commits"

    - name: Generate release notes based on semantic principles
      id: release-notes
      run: |
        echo ${{ steps.get-commits.outputs.commits }}

        # Decode the Base64 encoded commits
        commits=$(echo ${{ steps.get-commits.outputs.commits }} | base64 --decode)
        
        FEATURES=""
        FIXES=""
        OTHERS=""
        #for COMMIT_HASH in ${{ steps.get-commits.outputs.commits }}
        #do
        #  COMMIT_MSG=$(git log --format=%B -n 1 $COMMIT_HASH)
        #  echo "- ${COMMIT_MSG}\n"
          # Check if commit message starts with 'feat'
        #  if [[ $COMMIT_MSG == "feat:"* ]]; then
        #    FEATURES+="- ${COMMIT_MSG}\n"
          # Check if commit message starts with 'fix'
        #  elif [[ $COMMIT_MSG == "fix:"* ]]; then
        #    FIXES+="- ${COMMIT_MSG}\n"
        #  else
        #    OTHERS+="- ${COMMIT_MSG}\n"
        #  fi
        #done

        echo "$commits" | while IFS= read -r line; do
          echo "$line"
          if [[ "$line" == *"feat:"* ]]; then
            FEATURES+="- $line\n"
          elif [[ "$line" == *"fix:"* ]]; then
            FIXES+="- $line\n"
          else
            OTHERS+="- $line\n"
          fi
        done
        
        # Combine everything into RELEASE_NOTES
        RELEASE_NOTES=""
        if [ ! -z "$FEATURES" ]; then
          RELEASE_NOTES+="## Features\n$FEATURES\n"
        fi
        if [ ! -z "$FIXES" ]; then
          RELEASE_NOTES+="## Fixes\n$FIXES\n"
        fi
        if [ ! -z "$OTHERS" ]; then
          RELEASE_NOTES+="## Others\n$OTHERS\n"
        fi
        
        #echo "::set-output name=release_notes::$RELEASE_NOTES"
        
        # Save the release notes to a markdown file
        echo -e "$RELEASE_NOTES" > release_notes.md
        
        # Use the GITHUB_OUTPUT for setting formatted release notes as an output variable
        echo "release_notes<<EOF" >> $GITHUB_OUTPUT
        echo -e "$RELEASE_NOTES" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Upload Release Notes as Artifact
      if: ${{ env.APPA_AFFECTED == 'true' && env.VERSION_CHANGED == 'true' }}
      uses: actions/upload-artifact@v3
      with:
        name: release-notes
        path: release_notes.md

    - name: Download Release Notes
      if: ${{ env.APPA_AFFECTED == 'true' && env.VERSION_CHANGED == 'true' }}
      uses: actions/download-artifact@v3
      with:
        name: release-notes
        path: artifact-notes    
    
    - name: Create Tag
      if: ${{ env.APPA_AFFECTED == 'true' && env.VERSION_CHANGED == 'true' }}
      run: git tag ${{ steps.calc_version.outputs.next_version }}
    
    - name: Publish tags
      if: ${{ env.APPA_AFFECTED == 'true' && env.VERSION_CHANGED == 'true' }}
      run: git push --tags
      
    - name: Create Release for AppA
      if: ${{ env.APPA_AFFECTED == 'true' && env.VERSION_CHANGED == 'true' }}
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        release_name: '${{ steps.calc_version.outputs.next_version }}'
        tag_name: '${{ steps.calc_version.outputs.next_version }}'
        body_path: artifact-notes/release_notes.md
        draft: true
        prerelease: false
