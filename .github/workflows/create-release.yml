name: Release .NET Application AppA

on:
  workflow_dispatch

jobs:
  build-and-release:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3
      with:
        fetch-depth: 0 # Important to fetch all history for scripts calculating changes

    - name: Determine Changeset for AppA
      id: changeset
      run: |
        # Attempt to get the last tag, defaulting to the initial commit if none exist
        LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo $(git rev-list --max-parents=0 HEAD))

        # Echo the last tag or initial commit for debugging purposes
        echo "Using base reference: $LAST_TAG"
    
        # List all changed files since the last tag, filtering by those in the AppA or Core directories
        CHANGED_FILES=$(git diff --name-only $LAST_TAG HEAD | grep -E "src/Test/AppA/")
        echo "Changed Files: $CHANGED_FILES"
        
        # Check if the variable is empty or not
        if [[ -z "$CHANGED_FILES" ]]; then
          echo "APPA_AFFECTED=false" >> $GITHUB_ENV
          echo "APPA_AFFECTED=false"
        else
          echo "APPA_AFFECTED=true" >> $GITHUB_ENV
          echo "APPA_AFFECTED=true"
        fi

    - name: Build and Test Application
      if: env.APP_AFFECTED == 'true'
      run: |
        # Insert commands to build and test your .NET application
        dotnet build ./src/Test/AppA/Test.Api.App.A
        dotnet test ./src/Test/AppA/tests/Test.Api.App.A.Tests

    - name: Calculate next version for AppA
      id: calc_version
      if: env.APPA_AFFECTED == 'true'
      run: |
        # Enable case-insensitive matching
        shopt -s nocasematch
    
        # Ensure all tags are fetched
        git fetch --tags
    
        # Get the latest version tag for App1
        LATEST_TAG=$(git tag --list 'appA-*' --sort=-v:refname | head -n 1)
        if [[ -z "$LATEST_TAG" ]]; then
          LATEST_TAG="appA-v0.0.0"
        fi
        echo "Latest tag: $LATEST_TAG"
    
        # Initialize version components from the latest tag
        #PREFIX=$(echo $LATEST_TAG | grep -o '^[^-]*') # Extract prefix (appA-v)
        PREFIX=$(echo $LATEST_TAG | grep -oE '^[^-]+-v')
        echo "Prefix: $PREFIX"
        VERSION=$(echo $LATEST_TAG | sed -e "s/^$PREFIX//") # Remove prefix
        echo "Version less prefix: $(echo $LATEST_TAG | sed -e "s/^$PREFIX//")"
        MAJOR=$(echo $VERSION | cut -d '.' -f 1)
        echo "Major: $(echo $VERSION | cut -d '.' -f 1)"
        MINOR=$(echo $VERSION | cut -d '.' -f 2)
        echo "Minor: $(echo $VERSION | cut -d '.' -f 2)"
        PATCH=$(echo $VERSION | cut -d '.' -f 3)
        echo "Patch: $(echo $VERSION | cut -d '.' -f 3)"
    
        # Initialize increment variables
        MAJOR_INC=0
        MINOR_INC=0
        PATCH_INC=0
    
        # Use git diff to analyze commits for version bump, filtering by appA directory
        COMMIT_IDS=$(git log $LATEST_TAG..HEAD --pretty=format:"%H")
        for COMMIT_ID in $COMMIT_IDS
        do
          # Check if the commit affects the appA directory
          if git diff --name-only $COMMIT_ID^! | grep -q 'src/Test/AppA/'; then
            #COMMIT_MSG=$(git log -1 --pretty=format:"%s" $COMMIT_ID)
            COMMIT_MSG=$(git log -1 --pretty=format:"%s" $COMMIT_ID)
            if [[ "$COMMIT_MSG" =~ BREAKING[[:space:]]CHANGE: ]]; then
              MAJOR_INC=1
              break # Stop processing further commits as major version increment is required
            elif [[ "$COMMIT_MSG" =~ ^feat: ]]; then
              MINOR_INC=1
            elif [[ "$COMMIT_MSG" =~ ^fix: ]]; then
              PATCH_INC=1
            fi
          fi
        done

        # Disable case-insensitive matching after use
        shopt -u nocasematch
    
        # Calculate next version based on increments
        if [[ $MAJOR_INC -eq 1 ]]; then
          MAJOR=$(($MAJOR + 1))
          MINOR=0
          PATCH=0
        elif [[ $MINOR_INC -eq 1 ]]; then
          MINOR=$(($MINOR + 1))
          PATCH=0
        elif [[ $PATCH_INC -eq 1 ]]; then
          PATCH=$(($PATCH + 1))
        fi
    
        NEXT_VERSION="$PREFIX-$MAJOR.$MINOR.$PATCH"
        echo "Next version: $NEXT_VERSION"
        echo "next_version=$NEXT_VERSION" >> $GITHUB_OUTPUT
        
        if [[ "$NEXT_VERSION" == "$LATEST_TAG" ]]; then
          echo "VERSION_CHANGED=false" >> $GITHUB_ENV
          echo "VERSION_CHANGED=false"
        else
          echo "VERSION_CHANGED=true" >> $GITHUB_ENV
          echo "VERSION_CHANGED=true"
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Generate Release Notes
      id: release_notes
      if: ${{ env.APPA_AFFECTED == 'true' && env.VERSION_CHANGED == 'true' && env.VERSION_CHANGED == 'false' }}
      run: |
        # Attempt to get the last tag, default to the initial commit if none exist
        LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo $(git rev-list --max-parents=0 HEAD))
        echo "Generating release notes from: $LAST_TAG"
    
        # Check if LAST_TAG is the initial commit due to lack of tags
        IS_FIRST_TAG=$(if [ "$LAST_TAG" == "$(git rev-list --max-parents=0 HEAD)" ]; then echo "true"; else echo "false"; fi)
    
        # Generate release notes
        if [ "$IS_FIRST_TAG" == "true" ]; then
          # Handle the first tag scenario
          echo "Initial Release" > release_notes.md
          git log --pretty=format:"- %s" $(git rev-list --max-parents=0 HEAD)..HEAD -- src/Test/AppA/ >> release_notes.md
        else
          # Handle subsequent tags
          git log $LAST_TAG..HEAD --pretty=format:"- %s" -- src/Test/AppA/ > release_notes.md
        fi
    
        # Print release notes for debug purposes
        cat release_notes.md
    
        # Set the release notes in the environment variable
        #echo "RELEASE_NOTES<<EOF" >> $GITHUB_ENV
        #cat release_notes.md >> $GITHUB_ENV
        #echo "EOF" >> $GITHUB_ENV

    - name: Generate Formatted Release Notes
      id: generate_release_notes
      run: |
        # Enable extended globbing for more complex pattern matching
        shopt -s extglob
        
        # Initialize variables to store categorized commit messages
        FEATURES=""
        FIXES=""
        BREAKING_CHANGES=""
        echo "1"
    
        # Check if the last tag exists and get its hash; otherwise, use the first commit.
        LAST_TAG_HASH=$(git rev-list -n 1 $(git describe --tags --abbrev=0) 2>/dev/null || git rev-list --max-parents=0 HEAD)
      
        # Loop through each commit affecting 'src/Test/AppA', since the last tag
        while IFS= read -r COMMIT_HASH; do
          # Get the commit message
          COMMIT_MESSAGE=$(git log -1 --pretty=format:"%s" ${COMMIT_HASH})
      
          # Categorize the commit based on its message
          if [[ "$COMMIT_MESSAGE" == feat:* ]]; then
            FEATURES+="\n- ${COMMIT_MESSAGE#*: } (${COMMIT_HASH:0:7})"
          elif [[ "$COMMIT_MESSAGE" == fix:* ]]; then
            FIXES+="\n- ${COMMIT_MESSAGE#*: } (${COMMIT_HASH:0:7})"
          elif [[ "$COMMIT_MESSAGE" =~ BREAKING[[:space:]]CHANGE || "$COMMIT_MESSAGE" =~ \! ]]; then
            BREAKING_CHANGES+="\n- ${COMMIT_MESSAGE#*: } (${COMMIT_HASH:0:7})"
          fi
        done < <(git log ${LAST_TAG_HASH}..HEAD --pretty=format:"%H" -- src/Test/AppA/)
      
        # Assemble the release notes
        RELEASE_NOTES="# Release Notes for AppA\n## Features${FEATURES}\n## Fixes${FIXES}\n## Breaking Changes${BREAKING_CHANGES}"
      
        # Save the release notes to a markdown file
        echo -e "$RELEASE_NOTES" > release_notes.md
      
        # Use the GITHUB_OUTPUT for setting formatted release notes as an output variable
        echo "release_notes<<EOF" >> $GITHUB_OUTPUT
        echo -e "$RELEASE_NOTES" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
      shell: bash

    - name: Upload Release Notes as Artifact
      if: ${{ env.APPA_AFFECTED == 'true' && env.VERSION_CHANGED == 'true' }}
      uses: actions/upload-artifact@v3
      with:
        name: release-notes
        path: release_notes.md

    - name: Download Release Notes
      if: ${{ env.APPA_AFFECTED == 'true' && env.VERSION_CHANGED == 'true' }}
      uses: actions/download-artifact@v3
      with:
        name: release-notes
        path: artifact-notes
    
    - name: Create Tag
      if: ${{ env.APPA_AFFECTED == 'true' && env.VERSION_CHANGED == 'true' }}
      run: git tag ${{ steps.calc_version.outputs.next_version }}
    
    - name: Publish tags
      if: ${{ env.APPA_AFFECTED == 'true' && env.VERSION_CHANGED == 'true' }}
      run: git push --tags
      
    - name: Create Release for AppA
      if: ${{ env.APPA_AFFECTED == 'true' && env.VERSION_CHANGED == 'true' }}
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        release_name: '${{ steps.calc_version.outputs.next_version }}'
        tag_name: '${{ steps.calc_version.outputs.next_version }}'
        body_path: artifact-notes/release_notes.md
        draft: true
        prerelease: false
