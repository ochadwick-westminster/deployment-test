name: Release .NET Application Refactored

on:
  workflow_dispatch:
    inputs:
      APP_NAME:
        type: choice
        options: 
        - 'Please select an option...'
        - 'AppA'
        - 'AppB'
        required: true
        default: 'Please select an option...'
        description: App to create a release for

env:
  APP_PATH: 'src/Test/${{ inputs.APP_NAME }}/'
  CORE_PATH: 'src/Test/Core/'
  
jobs:
  validate-inputs:
    runs-on: ubuntu-latest
    steps:
      - name: Validate APP_NAME
        run: |
          if [[ "${{ inputs.APP_NAME }}" == "Please select an option..." ]]; then
            echo "Error: You must select a valid application to release."
            exit 1
          fi
          
  build-and-release:
    needs: validate-inputs
    runs-on: ubuntu-latest
    permissions:
      contents: write
      discussions: write
    env:
      APP_PATH: 'src/Test/${{ inputs.APP_NAME }}/'
      CORE_PATH: 'src/Test/Core/'
      APP_NAME: ${{ github.event.inputs.APP_NAME }}
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0 # Important to fetch all history for scripts calculating changes

    - name: Set execute permissions on scripts
      run: chmod +x ./.github/scripts/assess-changes.sh

    - name: Run assess-changes script
      run: ./.github/scripts/assess-changes.sh
      env:
        GITHUB_ENV: ${{ env.GITHUB_ENV }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        APP_NAME: ${{ github.event.inputs.APP_NAME }}

    - name: Build and Test Application
      run: |
        # Insert commands to build and test your .NET application
        dotnet build ./$APP_PATH/Test.Api.App.A --configuration Release
        dotnet test ./$APP_PATH/tests/Test.Api.App.A.Tests

    - name: Publish the application
      run: dotnet publish ./$APP_PATH/Test.Api.App.A -c Release -o publish

    - name: Package Application
      run: zip -r $NEXT_VERSION.zip publish/

    - name: Get commits since last tag for the application
      if: true
      id: get-commits
      run: |
        echo $LAST_TAG

        #${{ env.APP_AFFECTED == 'true' && env.VERSION_CHANGED == 'true' }}
        echo "APP_AFFECTED = $APP_AFFECTED"
        echo "VERSION_CHANGED = $VERSION_CHANGED"
        
        commits=$(git log $LAST_TAG..HEAD --no-merges --pretty=format:"%h %s" -- $APP_PATH $CORE_PATH | base64 -w 0)

        # Use GITHUB_OUTPUT to set the output variable
        echo "commits=$commits" >> $GITHUB_OUTPUT

    - name: Generate release notes based on semantic principles
      if: ${{ env.APP_AFFECTED == 'true' && env.VERSION_CHANGED == 'true' }}
      id: release-notes
      run: |
        #Decode the Base64 encoded commits
        commits=$(echo ${{ steps.get-commits.outputs.commits }} | base64 --decode)

        echo "Generating release notes..."
        RELEASE_NOTES="## Release Notes"
        FIXES=""
        OTHERS=""
        FEATURES=""

        # Enable case-insensitive matching
        shopt -s nocasematch

        while IFS= read -r commit; do
          echo "Processing commits:"
          if [[ -z "$commit" ]]; then
            echo "Commit empty"
            continue
          fi

          # Extract commit hash, which is the first part before a space
          commit_hash=$(echo $commit | awk '{print $1}')
          echo "Hash: $commit_hash"

          # Extract commit title, which is the second part before a space
          commit_title=$(echo "$commit" | cut -d ' ' -f 2-)
          echo "Title: $commit_title"

          # Get the full commit message
          full_message=$(git show -s --format=%B $commit_hash)
          echo "Full Commit: $full_message"

          commit_message="$commit_title"
          if [[ "$full_message" =~ BREAKING[[:space:]]CHANGE: ]] || [[ "$commit_title" =~ ^[a-z]+!: ]]; then
            commit_message+=$' (BREAKING CHANGE)'
          fi
          echo "Commit message for release note: $commit_message"
          
          if [[ "$commit_title" =~ ^feat ]]; then    
            FEATURES+="- $(echo $commit_message | cut -d ' ' -f2-)\n"
          elif [[ "$commit_title" =~ ^fix ]]; then
            FIXES+="- $(echo $commit_message | cut -d ' ' -f2-)\n"
          else
            OTHERS+="- $commit_message\n"
          fi
        done < <(echo "$commits" | sed '/^$/d')

        # Disable case-insensitive matching after use
        shopt -u nocasematch

        if [[ $FEATURES ]]; then
          RELEASE_NOTES+="\n\n### Features\n$FEATURES"
        fi
        if [[ $FIXES ]]; then
          RELEASE_NOTES+="\n\n### Fixes\n$FIXES"
        fi
        if [[ $OTHERS ]]; then
          RELEASE_NOTES+="\n\n### Others\n$OTHERS"
        fi
        
        echo "Release notes:"
        echo -e "$RELEASE_NOTES"
        echo "===="
        
        # Save the release notes to a markdown file
        echo -e "$RELEASE_NOTES" > release_notes.md

    - name: Upload Release Notes as Artifact
      if: ${{ env.APP_AFFECTED == 'true' && env.VERSION_CHANGED == 'true' }}
      uses: actions/upload-artifact@v4
      with:
        name: release-notes
        path: release_notes.md 

    - name: Create and Publish Tag
      if: env.APP_AFFECTED == 'true' && env.VERSION_CHANGED == 'true'
      run: |
        git tag $NEXT_VERSION
        git push --tags
        
    - name: Create Release for App
      if: ${{ env.APP_AFFECTED == 'true' && env.VERSION_CHANGED == 'true' }}
      uses: softprops/action-gh-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        name: '${{ env.NEXT_VERSION }}'
        tag_name: '${{ env.NEXT_VERSION }}'
        body_path: release_notes.md
        draft: false
        prerelease: false
        files: ${{ env.NEXT_VERSION }}.zip
