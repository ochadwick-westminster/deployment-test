name: Release .NET Application AppA

on:
  workflow_dispatch

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    env:
      APP_PATH: 'src/Test/AppA/'
    steps:
    - uses: actions/checkout@v3
      with:
        fetch-depth: 0 # Important to fetch all history for scripts calculating changes

    - name: Determine Changeset and Version Impact
      id: prep
      run: |
        LAST_TAG=$(git tag --list 'appA*' --sort=-version:refname | head -n 1)
        if [ -z "$LAST_TAG" ]; then
          LAST_TAG=$(git rev-list --max-parents=0 HEAD)
        fi
        echo "LAST_TAG=$LAST_TAG" >> $GITHUB_ENV

        CHANGED_FILES=$(git diff --name-only $LAST_TAG HEAD | grep -E "$APP_PATH" || true)
        echo "Changed Files: $CHANGED_FILES"
        if [[ -z "$CHANGED_FILES" ]]; then
          echo "APPA_AFFECTED=false" >> $GITHUB_ENV
          exit 1
        else
          echo "APPA_AFFECTED=true" >> $GITHUB_ENV
        fi

        # Version calculation logic here, setting VERSION_CHANGED as needed
        # Enable case-insensitive matching
        shopt -s nocasematch

        # Initialize version components from the latest tag
        PREFIX=$(echo $LAST_TAG | grep -oE '^[^-]+-v')
        VERSION=$(echo $LAST_TAG | sed -e "s/^$PREFIX//") # Remove prefix
        MAJOR=$(echo $VERSION | cut -d '.' -f 1)
        MINOR=$(echo $VERSION | cut -d '.' -f 2)
        PATCH=$(echo $VERSION | cut -d '.' -f 3)
    
        # Initialize increment variables
        MAJOR_INC=0
        MINOR_INC=0
        PATCH_INC=0

        # Check if the latest tag points to the initial commit (first release scenario)
        if [[ $LAST_TAG == "appA-v0.0.0" ]]; then
          # For the first release, consider all commits for AppA since the beginning of the repository
          echo "First release"
          COMMIT_IDS=$(git log --pretty=format:"%H" -- src/Test/AppA/)
        else
          echo "not first release"
          # For subsequent releases, only consider commits since the latest tag
          COMMIT_IDS=$(git log $LAST_TAG..HEAD --pretty=format:"%H" -- src/Test/AppA/)
        fi

        # Use git diff to analyze commits for version bump, filtering by appA directory
        #COMMIT_IDS=$(git log $LAST_TAG..HEAD --pretty=format:"%H")
        
        for COMMIT_ID in $COMMIT_IDS
        do
          # Check if the commit affects the appA directory
          if git diff --name-only $COMMIT_ID^! | grep -q 'src/Test/AppA/'; then
            #COMMIT_MSG=$(git log -1 --pretty=format:"%s" $COMMIT_ID)
            COMMIT_MSG=$(git log -1 --pretty=format:"%s" $COMMIT_ID)
            if [[ "$COMMIT_MSG" =~ BREAKING[[:space:]]CHANGE: ]]; then
              MAJOR_INC=1
              break # Stop processing further commits as major version increment is required
            elif [[ "$COMMIT_MSG" =~ ^feat: ]]; then
              MINOR_INC=1
            elif [[ "$COMMIT_MSG" =~ ^fix: ]]; then
              PATCH_INC=1
            fi
          fi
        done

        # Disable case-insensitive matching after use
        shopt -u nocasematch
    
        # Calculate next version based on increments
        if [[ $MAJOR_INC -eq 1 ]]; then
          MAJOR=$(($MAJOR + 1))
          MINOR=0
          PATCH=0
        elif [[ $MINOR_INC -eq 1 ]]; then
          MINOR=$(($MINOR + 1))
          PATCH=0
        elif [[ $PATCH_INC -eq 1 ]]; then
          PATCH=$(($PATCH + 1))
        fi
    
        NEXT_VERSION="$PREFIX$MAJOR.$MINOR.$PATCH"
        echo "Next version: $NEXT_VERSION"
        echo "NEXT_VERSION=$NEXT_VERSION" >> $GITHUB_ENV
        
        if [[ "$NEXT_VERSION" == "$LAST_TAG" ]]; then
          echo "VERSION_CHANGED=false" >> $GITHUB_ENV
          echo "VERSION_CHANGED=false"
        else
          echo "VERSION_CHANGED=true" >> $GITHUB_ENV
          echo "VERSION_CHANGED=true"
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Build and Test Application
      if: env.APP_AFFECTED == 'true'
      run: |
        # Insert commands to build and test your .NET application
        dotnet build ./src/Test/AppA/Test.Api.App.A
        dotnet test ./src/Test/AppA/tests/Test.Api.App.A.Tests

    - name: Get commits since last tag for the application
      id: get-commits
      run: |
        echo $LAST_TAG
        if [[ -n "$LAST_TAG" ]]; then
          commits=$(git log ${LAST_TAG}..HEAD --pretty=format:"%h %s" -- 'src/Test/AppA/' | base64 -w 0)
        else
          commits=$(git log --pretty=format:"%h %s" -- 'src/Test/AppA/' | base64 -w 0)
        fi
        
        echo "Outputting commits:"
        echo $commits
        # Use GITHUB_OUTPUT to set the output variable
        echo "commits=$commits" >> $GITHUB_OUTPUT

    - name: Generate release notes based on semantic principles
      id: release-notes
      run: |
        echo ${{ steps.get-commits.outputs.commits }}

        # Decode the Base64 encoded commits
        commits=$(echo ${{ steps.get-commits.outputs.commits }} | base64 --decode)

        echo "Generating release notes..."
        RELEASE_NOTES="## Release Notes"
        FIXES=""
        OTHERS=""
        FEATURES=""

        while IFS= read -r line; do
          if [[ "$line" == *"feat:"* ]]; then
            #FEATURES+="- $line\n"
            FEATURES+="- $(echo $line | cut -d ' ' -f3-)\n"
          elif [[ "$line" == *"fix:"* ]]; then
            FIXES+="- $line\n"
          else
            OTHERS+="- $line\n"
          fi
        done < <(echo "$commits")
        
        if [[ $FEATURES ]]; then
          RELEASE_NOTES+="\n\n### Features\n$FEATURES"
        fi
        if [[ $FIXES ]]; then
          RELEASE_NOTES+="\n\n### Fixes\n$FIXES"
        fi
        if [[ $OTHERS ]]; then
          RELEASE_NOTES+="\n\n### Others\n$OTHERS"
        fi
        
        echo "Release notes:"
        echo -e "$RELEASE_NOTES"
        echo "===="
        
        #echo "::set-output name=release_notes::$RELEASE_NOTES"
        
        # Save the release notes to a markdown file
        echo -e "$RELEASE_NOTES" > release_notes.md
        
        # Use the GITHUB_OUTPUT for setting formatted release notes as an output variable
        echo "release_notes<<EOF" >> $GITHUB_OUTPUT
        echo -e "$RELEASE_NOTES" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Upload Release Notes as Artifact
      if: ${{ env.APPA_AFFECTED == 'true' && env.VERSION_CHANGED == 'true' }}
      uses: actions/upload-artifact@v3
      with:
        name: release-notes
        path: release_notes.md 

    - name: Create and Publish Tag
      if: env.APPA_AFFECTED == 'true' && env.VERSION_CHANGED == 'true'
      run: |
        git tag $NEXT_VERSION
        git push --tags
        
    - name: Create Release for AppA
      if: ${{ env.APPA_AFFECTED == 'true' && env.VERSION_CHANGED == 'true' }}
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        release_name: '${{ env.NEXT_VERSION }}'
        tag_name: '${{ env.NEXT_VERSION }}'
        body_path: release_notes.md
        draft: true
        prerelease: false
